package net.mathmods.towerdefense;

import java.awt.Image;

import javax.swing.ImageIcon;

public class Tower implements Cloneable {

	private String textureFile = "";
	public Image texture;
	
	public static final Tower[] towerList = new Tower[200];
	public static final Tower towerLightning = new TowerLightning(0, 10, 3, 1).getTexture("lightning");
	
	public int id;
	public int cost;
	public int range;
	public int DAMAGENEUTRAL = 1;
	public int DAMAGEFAST = 2;
	public int DAMAGESLOW = 3;
	public int ATTACKDAMAGE;
	public int x;
	public int y;
	
	public Tower(int id, int cost, int range, int damage){
		if(towerList[id] != null){
			System.err.println("[TOWERERROR] 2 towers with same id!");
		}else{
			towerList[id] = this;
			this.id = id;
			this.cost = cost;
			this.range = range;
			this.ATTACKDAMAGE = damage;
		}
	}
	
	public Tower getTexture(String texture){
		this.textureFile = "res/towers/" + texture +".png";
		Image i;
		i = new ImageIcon(textureFile).getImage();
		this.texture = i.getScaledInstance((int)Screen.towerWidth, (int)Screen.towerHeight, Image.SCALE_SMOOTH);
		
		return null;
	}
	
	int Delay;
	int maxDelay;
	
	public void update(EnemyMove[] map){
		if(ATTACKDAMAGE == DAMAGENEUTRAL){
			maxDelay = 1000;
		}else if(ATTACKDAMAGE == DAMAGEFAST){
			maxDelay = 500;
		}else if(ATTACKDAMAGE == DAMAGESLOW){
			maxDelay = 1500;
		}
		
		if(Delay < maxDelay){
			Delay++;
		}else{
			Delay = 0;
			boolean stop = false;
			for(int x = 0; x<range*2 + 1; x++){
				for(int y = 0; y<range*2 + 1; y++){
					if(Screen.map[x][y] == 1){
						for(int i = 0; i<map.length; i++){
							if(map[i] != null){
								if(map[i].routePosX == x && map[i].routePosY == y){
									if(ATTACKDAMAGE == DAMAGENEUTRAL){
										map[i].health -= 10;
									}else if(ATTACKDAMAGE == DAMAGEFAST){
										map[i].health -= 5;
									}else if(ATTACKDAMAGE == DAMAGESLOW){
										map[i].health -= 20;
									}
									stop = true;
									break;
								}
							}
						}
					}
					if(stop){
						break;
					}
				}
				if(stop){
					break;
				}
			}
		}
		
	}
	
	protected Object clone(){
		try {
			return super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
}
